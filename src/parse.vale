
fn parseMetadata(input &InputIter) Metadata {
  title! = "".slice();
  subtitle! = "".slice();
  author! = "".slice();
  date! = "".slice();
  path! = "".slice();
  namespace! = "".slice();

  if (input.skipIfNext("---\n")) {
    while (not input.skipIfNext("---\n")) {
      line = input.getUntilExpected("\n");

      maybeAttrNameAndValue = line.splitOnce(":");
      if (maybeAttrNameAndValue.isEmpty()) {
        panic("Invalid attribute line, must have a colon in it! Received:\n" + line);
      }
      (attrName!, attrValue!) = maybeAttrNameAndValue.get();
      mut attrName = attrName.trim();
      mut attrValue = attrValue.trim();

      if (attrName == "title") {
        mut title = attrValue;
      } else if (attrName == "subtitle") {
        mut subtitle = attrValue;
      } else if (attrName == "author") {
        mut author = attrValue;
      } else if (attrName == "date") {
        mut date = attrValue;
      } else if (attrName == "path") {
        mut path = attrValue;
      } else if (attrName == "namespace") {
        mut namespace = attrValue;
      } else {
        panic("Unknown attribute: " + attrName);
      }
    }
  }

  ret Metadata(title, subtitle, author, date, path, namespace);
}



fn parseList(
    collectedNotes &CollectedNotes,
    paragraph StrSlice)
UnorderedList {
  iter = InputIter(paragraph.trimnl(), true);

  rootList = UnorderedList(List<ListMember>());
  // A stack of all the currently open lists.
  openLists = List<&UnorderedList>();
  openLists.add(&rootList);


  currentIndentation! = 1;

  while (iter.hasNext()) {
    thisListItemIndentation! = 1;
    while (iter.skipIfNext("   ")) {
      mut thisListItemIndentation = thisListItemIndentation + 1;
    }
    if (not iter.skipIfNext(" * ")) {
      panic("Expected list item!");
    }

    while (thisListItemIndentation > currentIndentation) {
      newList = UnorderedList(List<ListMember>());
      newListBorrow = &newList;
      openLists.get(openLists.len() - 1).get().members.add(newList);
      openLists.add(newListBorrow);

      mut currentIndentation = currentIndentation + 1;
    }
    while (thisListItemIndentation < currentIndentation) {
      openLists.remove(openLists.len() - 1);

      mut currentIndentation = currentIndentation - 1;
    }

    line = iter.getUntilMaybe("\n");
    lineContents = parseLine(collectedNotes, &InputIter(line, true));
    openLists.get(openLists.len() - 1).get().members.add(ListItem(lineContents));
  }

  while (currentIndentation > 0) {
    openLists.remove(openLists.len() - 1);
    mut currentIndentation = currentIndentation - 1;
  }

  ret rootList;
}


fn parseSeparateNotes(
    collectedNotes &CollectedNotes,
    section! StrSlice) {
  iter = InputIter(section.trim(), true);
  iter.skipExpect("#");
  while (iter.hasNext()) {
    id = ("#" + iter.getUntilExpected(":")).slice();
    println("Parsing low note " + id);
    noteContents = iter.getUntilMaybe("#").trim();
    vassert(not noteContents.has("\n\n\n"), "Note shouldnt contain section break");
    noteOutput = parseSection(collectedNotes, noteContents);
    collectedNotes.addSeparateNote(id, noteOutput);
  }
}


fn parseInlineNode(
    collectedNotes &CollectedNotes,
    iter &InputIter)
InlineNode {
  if (iter.previousWasBeginOrWhitespace and iter.nextIs("*")) {
    ret parseBold(collectedNotes, iter);
  } else if (iter.previousWasBeginOrWhitespace and iter.nextIs("_")) {
    ret parseItalic(collectedNotes, iter);
  } else if (iter.previousWasBeginOrWhitespace and iter.skipIfNext("[")) {
    note = iter.getUntilExpected("]");
    ret addInlineNote(collectedNotes, note);
  } else if (iter.previousWasBeginOrWhitespace and iter.skipIfNext("\{")) {
    code = iter.getUntilExpected("\}");
    ret Code(code);
  } else {
    next = iter.getNext();
    ret Text(next);
  }
}

fn parseBold(
    collectedNotes &CollectedNotes,
    iter &InputIter)
Bold {
  iter.skipExpect("*");

  inners = List<InlineNode>();

  running! = true;
  while (running and iter.hasNext()) {
    if (iter.skipIfNext("* ")) {
      mut running = false;
    } else if (iter.skipIfEndsWith("*")) {
      mut running = false;
    } else {
      inner = parseInlineNode(collectedNotes, iter);
      inners.add(inner);
    }
  }

  ret Bold(Compound(inners));
}

fn parseItalic(
    collectedNotes &CollectedNotes,
    iter &InputIter)
Italic {
  iter.skipExpect("_");

  inners = List<InlineNode>();

  running! = true;
  while (running and iter.hasNext()) {
    if (iter.skipIfNext("_ ")) {
      mut running = false;
    } else if (iter.skipIfEndsWith("_")) {
      mut running = false;
    } else {
      inner = parseInlineNode(collectedNotes, iter);
      inners.add(inner);
    }
  }

  ret Italic(Compound(inners));
}

fn parseLine(
    collectedNotes &CollectedNotes,
    iter &InputIter)
InlineNode {
  inners = List<InlineNode>();
  while (iter.hasNext()) {
    inner = parseInlineNode(collectedNotes, iter);
    inners.add(inner);
  }
  ret Compound(inners);
}

fn parseSectionMember(
    collectedNotes &CollectedNotes,
    paragraphSource! StrSlice)
SectionMember {
  mut paragraphSource = paragraphSource.trimnl();

  if (paragraphSource.startsWith(" * ")) {
    ret parseList(collectedNotes, paragraphSource);
  } else {
    inlineNode = parseLine(collectedNotes, &InputIter(paragraphSource, true));
    ret Paragraph(inlineNode);
  }
}


fn parseSection(
    collectedNotes &CollectedNotes,
    section StrSlice)
Section {
  members = List<SectionMember>();
  each (&section.split("\n\n")) (paragraphSource!){
    mut paragraphSource = paragraphSource.trimnl();
    member = parseSectionMember(&collectedNotes, paragraphSource);
    members.add(member);
  }
  ret Section(members);
}






fn addInlineNote(
    self &CollectedNotes,
    noteContents StrSlice)
NoteAnchor {
  if (noteContents.startsWith("#")) {
    id = noteContents;
    vassert(not self.noteIds.contains(id), "Note " + id + " already exists!");
    self.noteIds.add(id);
    ret NoteAnchor(id);
  } else {
    subNotes = CollectedNotes();
    subNoteContents = parseLine(&subNotes, &InputIter(noteContents, true));
    paragraph = Paragraph(subNoteContents);
    section = Section(List<SectionMember>());
    section.members.add(paragraph);

    id = self.noteIds.len().str().slice();
    self.noteIds.add(id);
    self.noteContents.add(id, section);
    ret NoteAnchor(id);
  }
}
fn addSeparateNote(
    self &CollectedNotes,
    id StrSlice,
    note Section) {
  self.noteContents.add(id, note);
}

