
struct NotesCollector {
  nextId! int;
  ids List<int>;
  idByName HashMap<StrSlice, int, StrSliceHasher, StrSliceEquator>;
  nameById HashMap<int, StrSlice, IntHasher, IntEquator>;
  noteContentsById HashMap<int, Section, IntHasher, IntEquator>;
}
fn NotesCollector(nextId int) NotesCollector {
  NotesCollector(
    nextId,
    List<int>(),
    HashMap<StrSlice, int, StrSliceHasher, StrSliceEquator>(
      StrSliceHasher(), StrSliceEquator()),
    HashMap<int, StrSlice, IntHasher, IntEquator>(IntHasher(), IntEquator()),
    HashMap<int, Section, IntHasher, IntEquator>(IntHasher(), IntEquator()))
}
fn Notes(notesCollector NotesCollector) Notes {
  (nextId, ids, idByName, nameById, noteContentsById) = ^notesCollector;
  ret Notes(^ids, ^noteContentsById);
}


fn parse(filepath str) Page {
  s = readFileAsString(filepath);
  iter = InputIter(s.slice(), true);
  
  metadata = parseMetadata(iter);

  notesCollector! = NotesCollector(0);

  pageMembers = List<PageMember>();

  while (iter.hasNext()) {
    iter.skipNewlines();

    if (iter.skipIfNext("<notes/>") or iter.skipIfNext("<notes />")) {
      pageMembers.add(Notes(mut notesCollector = NotesCollector(notesCollector.nextId)));
    } else if (iter.nextIs("<notes>")) {
      parseSeparateNotes(notesCollector, iter);
      pageMembers.add(Notes(mut notesCollector = NotesCollector(notesCollector.nextId)));
    } else {
      section =
          parseSection(
              notesCollector,
              iter,
              &IFunction1<mut, &InputIter, bool>((iter){
                ret iter.hasNext() and not iter.nextIs("<notes") and not iter.nextIs("\n\n\n");
              }));
      pageMembers.add(^section);
    }
  }

  pageMembers.add(
      Notes(
          mut notesCollector = NotesCollector(notesCollector.nextId)));

  ret Page(^metadata, ^pageMembers);
}


fn parseMetadata(input &InputIter) Metadata {
  title! = "".slice();
  subtitle! = "".slice();
  author! = "".slice();
  date! = "".slice();
  realm! = "".slice();
  path! = "".slice();
  namespace! = "".slice();
  layout! = "".slice();
  seriesName! = "".slice();
  seriesEntries = List<Link>();

  if (input.skipIfNext("---\n")) {
    while (not input.skipIfNext("---\n")) {
      attrName = input.getUntilExpected(":");
      input.skipWhitespace();

      if (attrName == "title") {
        mut title = input.getUntilExpected("\n");
      } else if (attrName == "subtitle") {
        mut subtitle = input.getUntilExpected("\n");
      } else if (attrName == "author") {
        mut author = input.getUntilExpected("\n");
      } else if (attrName == "date") {
        mut date = input.getUntilExpected("\n");
      } else if (attrName == "realm") {
        mut realm = input.getUntilExpected("\n");
      } else if (attrName == "path") {
        mut path = input.getUntilExpected("\n");
      } else if (attrName == "namespace") {
        mut namespace = input.getUntilExpected("\n");
      } else if (attrName == "layout") {
        mut layout = input.getUntilExpected("\n");
      } else if (attrName == "series-name") {
        mut seriesName = input.getUntilExpected("\n");
      } else if (attrName == "series-entry") {
        seriesEntries.add(addLink(input));
        input.skipExpect("\n");
      } else {
        panic("Unknown attribute: " + attrName);
      }
    }
  }

  if (seriesEntries.len() > 0) {
    // A series link with an empty url represents the current page
    foundEmptyLink! = false;
    seriesEntries.each((link){
      if (link.text == "" and link.url == "") {
        vassert(not foundEmptyLink, "Already an empty series entry!");
        mut foundEmptyLink = true;
      }
    });
    vassert(foundEmptyLink, "No empty series entry!");
  }

  ret Metadata(title, subtitle, author, date, realm, path, seriesName, ^seriesEntries, layout, namespace);
}


fn nextIsListItem(originalIter &InputIter) bool {
  lookaheadIter = copy(originalIter);
  lookaheadIter.skipNewlines();
  while (lookaheadIter.skipIfNext("   ")) { }
  ret lookaheadIter.nextIs(" * ");
}


fn parseList(
    notesCollector &NotesCollector,
    iter &InputIter,
    continueF &IFunction1<mut, &InputIter, bool>)
UnorderedList {
  rootList = UnorderedList(List<ListMember>());
  // A stack of all the currently open lists.
  openLists = List<&UnorderedList>();
  openLists.add(rootList);

  while ((continueF)(iter) and iter.nextIsListItem()) {
    iter.skipNewlines();
    thisListItemIndentation! = 1;
    while (iter.skipIfNext("   ")) {
      mut thisListItemIndentation = thisListItemIndentation + 1;
    }
    iter.skipExpect(" * ");

    while (thisListItemIndentation > openLists.len()) {
      newList = UnorderedList(List<ListMember>());
      newListBorrow = newList;
      openLists.get(openLists.len() - 1).members.add(^newList);
      openLists.add(newListBorrow);
    }
    while (thisListItemIndentation < openLists.len()) {
      openLists.remove(openLists.len() - 1);
    }

    lineContents =
        parseLine(
            notesCollector,
            iter,
            &IFunction1<mut, &InputIter, bool>((iter){
              ret (continueF)(iter) and not iter.nextIs("\n");
            }));
    openLists.get(openLists.len() - 1).members.add(ListItem(^lineContents));
  }

  ret ^rootList;
}


fn parseQuote(
    notesCollector &NotesCollector,
    iter &InputIter,
    continueF &IFunction1<mut, &InputIter, bool>)
Quote {
  inlines = List<InlineNode>();

  while ((continueF)(iter) and iter.nextIs("> ")) {
    iter.skipExpect("> ");

    lineContents =
        parseInlines(
            notesCollector,
            iter,
            &IFunction1<mut, &InputIter, bool>((iter){
              ret (continueF)(iter) and not iter.nextIs("\n");
            }));
    while (lineContents.inners.len() > 0) {
      inlines.add(lineContents.inners.remove(0));
    }
  }

  ret Quote(Compound(^inlines));
}


fn parseSplit(
    notesCollector &NotesCollector,
    iter &InputIter)
Split {
  iter.skipExpect("<<<<");
  iter.skipNewlines();


  leftContinueF =
      IFunction1<mut, &InputIter, bool>((iter){
        if (not iter.hasNext()) {
          panic("<<<< must end with \/\/\/\/");
        }
        ret not iter.nextIs("\/\/\/\/");
      });

  leftSections = List<Section>();

  while ((leftContinueF)(iter)) {
    leftSections.add(
        parseSection(
            notesCollector,
            iter,
            &IFunction1<mut, &InputIter, bool>((iter){
              ret (leftContinueF)(iter) and not iter.nextIs("\n\n\n");
            })));
    iter.skipNewlines();
  }

  iter.skipExpect("\/\/\/\/");
  iter.skipNewlines();


  rightContinueF =
      IFunction1<mut, &InputIter, bool>((iter){
        if (not iter.hasNext()) {
          panic("\/\/\/\/ must end with >>>>");
        }
        ret not iter.nextIs(">>>>");
      });

  rightSections = List<Section>();

  while ((rightContinueF)(iter)) {
    rightSections.add(
        parseSection(
            notesCollector,
            iter,
            &IFunction1<mut, &InputIter, bool>((iter){
              ret (rightContinueF)(iter) and not iter.nextIs("\n\n\n");
            })));
    iter.skipNewlines();
  }

  iter.skipExpect(">>>>");

  ret Split(^leftSections, ^rightSections);
}


fn nextIsNoteBegin(originalIter &InputIter) bool {
  lookaheadIter = copy(originalIter);
  if (not lookaheadIter.skipIfNext("\n\n")) {
    ret false;
  }
  lookaheadIter.skipNewlines();
  ret lookaheadIter.skipIfNext("#");
}


fn parseSeparateNotes(
    notesCollector &NotesCollector,
    iter &InputIter) {
  iter.skipExpect("<notes>");
  iter.skipNewlines();

  continueF =
      IFunction1<mut, &InputIter, bool>((iter){
        if (not iter.hasNext()) {
          panic("<notes> must end with </notes>");
        }
        ret not iter.nextIs("</notes>");
      });

  while ((continueF)(iter)) {
    iter.skipNewlines();
    iter.skipExpect("#");
    noteId = iter.getUntilExpected(":");

    noteOutput =
        parseSection(
            notesCollector,
            iter,
            &IFunction1<mut, &InputIter, bool>((iter){
              ret (continueF)(iter) and not iter.nextIsNoteBegin();
            }));
    iter.skipNewlines();
    notesCollector.addSeparateNote(noteId, ^noteOutput);
  }

  iter.skipIfNext("</notes>");
}


fn parseInlineNode(
    notesCollector &NotesCollector,
    iter &InputIter)
Opt<InlineNode> {
  if (not iter.previousWasWordChar and iter.nextIs("*")) {
    ret Some<InlineNode>(parseBold(notesCollector, iter));
  } else if (not iter.previousWasWordChar and iter.nextIs("_")) {
    ret Some<InlineNode>(parseItalic(notesCollector, iter));
  } else if (iter.nextIs("[#")) {
    ret Some<InlineNode>(addInlineNote(notesCollector, iter));
  } else if (not iter.previousWasWordChar and iter.nextIs("[")) {
    ret Some<InlineNode>(addLink(iter));
  } else if (not iter.previousWasWordChar and iter.skipIfNext("`")) {
    code = iter.getUntilExpected("`");
    ret Some<InlineNode>(InlineCode(code));
  } else {
    ret None<InlineNode>();
  }
}

fn parseInlines(
    notesCollector &NotesCollector,
    iter &InputIter,
    continueF &IFunction1<mut, &InputIter, bool>)
Compound {
  inners = List<InlineNode>();

  currentTextNode! StrSlice = "".slice();

  running! = true;
  while (running and iter.hasNext()) {
    if (not (continueF)(iter)) {
      mut running = false;
    } else {
      maybeInner = parseInlineNode(notesCollector, iter);
      if (not maybeInner.isEmpty()) {
        if (currentTextNode != "") {
          inners.add(Text(mut currentTextNode = "".slice()));
        }
        inners.add(maybeInner^.get());
      } else {
        maybeInner^.drop();
        mut currentTextNode = (currentTextNode + iter.getNext()).slice();
      }
    }
  }
  if (currentTextNode != "") {
    inners.add(Text(mut currentTextNode = "".slice()));
  }

  ret Compound(^inners);
}

fn parseBold(
    notesCollector &NotesCollector,
    iter &InputIter)
Bold {
  iter.skipExpect("*");

  compound =
    parseInlines(
      notesCollector,
      iter,
      &IFunction1<mut, &InputIter, bool>((iter){
        if (not iter.hasNext()) {
          panic("Must end bold!");
          ret false;
        } else if (iter.nextIs("*")) {
          iter.skipExpect("*");
          ret false;
        } else {
          ret true;
        }
      }));

  ret Bold(^compound);
}

fn parseItalic(
    notesCollector &NotesCollector,
    iter &InputIter)
Italic {
  iter.skipExpect("_");

  compound =
    parseInlines(
      notesCollector,
      iter,
      &IFunction1<mut, &InputIter, bool>((iter){
        if (not iter.hasNext()) {
          panic("Must end italic!");
          ret false;
        } else if (iter.nextIs("_ ") or iter.nextIs("_.")) {
          iter.skipExpect("_");
          ret false;
        } else if (iter.skipIfEndsWith("_")) {
          ret false;
        } else {
          ret true;
        }
      }));

  ret Italic(^compound);
}

fn parseLine(
    notesCollector &NotesCollector,
    iter &InputIter,
    continueF &IFunction1<mut, &InputIter, bool>)
InlineNode {
  ret parseInlines(
    notesCollector,
    iter,
    &IFunction1<mut, &InputIter, bool>((iter){
      ret (continueF)(iter) and iter.hasNext();
    }));
}



fn parseTextUntil(
    iter &InputIter,
    continueF &IFunction1<mut, &InputIter, bool>)
StrSlice {
  code! StrSlice = "".slice();

  running! = true;
  while (running and iter.hasNext()) {
    if (not (continueF)(iter)) {
      mut running = false;
    } else {
      mut code = (code + iter.getNext()).slice();
    }
  }

  ret code;
}


fn parseCodeSnippet(notesCollector &NotesCollector, iter &InputIter) CodeSnippet {
  iter.skipExpect("```");

  lang = iter.getUntilExpected("\n");

  // We register the chevron notes here and leave the code mostly untouched, because:
  // - If we slice up the code into a Compound with Text and NoteAnchor, then
  //   its harder later on to merge the text parts of the code back together to
  //   feed into the syntax highlighter (and hard to know where to put the
  //   anchors back in).
  // - If we syntax highlight the code now, it means we're making the decision
  //   now on how to display it, which belongs in the printing stage.
  // Though, we do replace the note name with a note id, to be consistent with how
  // NoteAnchor works.

  code =
      parseChevronNoteAnchors(
          notesCollector,
          parseTextUntil(
              iter,
              &IFunction1<mut, &InputIter, bool>((it){
                if (not it.hasNext()) {
                  panic("``` must have matching \\n```!");
                }
                ret not it.skipIfNext("\n```");
              })));

  ret CodeSnippet(lang, code.slice());
}


// Looks through for any chevron notes like «mynote» and registers them with
// the notes collector.
fn parseChevronNoteAnchors(notesCollector &NotesCollector, haystack StrSlice) str {
  result! = "";

  iter = InputIter(haystack, true);
  while (iter.hasNext()) {
    if (iter.skipIfNext("«")) {
      noteName = iter.getUntilExpected("»");
      id = addNamedNoteAnchor(notesCollector, noteName);
      mut result = result + ("«" + id + "»");
    } else {
      mut result = result + iter.getNext();
    }
  }

  ret result;
}


fn parseSection(
    notesCollector &NotesCollector,
    iter &InputIter,
    continueF &IFunction1<mut, &InputIter, bool>)
Section {
  sectionMembers = List<SectionMember>();

  while ((continueF)(iter)) {
    iter.skipNewlines();

    if (iter.nextIs("```")) {
      sectionMembers.add(parseCodeSnippet(notesCollector, iter));
    } else if (iter.nextIs("#")) {
      headerStrength! = 0;
      while (iter.skipIfNext("#")) {
        mut headerStrength = headerStrength + 1;
      }
      headerContents =
          parseInlines(
              notesCollector,
              iter,
              &IFunction1<mut, &InputIter, bool>((it){
                ret iter.hasNext() and not iter.nextIs("\n");
              }));
      sectionMembers.add(Header(headerStrength, ^headerContents));
    } else if (iter.nextIs("<<<<")) {
      sectionMembers.add(parseSplit(notesCollector, iter));
    } else if (iter.nextIs(" * ")) {
      sectionMembers.add(
          parseList(
              notesCollector,
              iter,
              &IFunction1<mut, &InputIter, bool>((iter){
                ret (continueF)(iter) and not iter.nextIs("\n\n");
              })));
    } else if (iter.nextIs("> ")) {
      sectionMembers.add(
          parseQuote(
              notesCollector,
              iter,
              &IFunction1<mut, &InputIter, bool>((iter){
                ret (continueF)(iter) and not iter.nextIs("\n\n");
              })));
    } else {
      inlineNode =
          parseLine(
              notesCollector,
              iter,
              &IFunction1<mut, &InputIter, bool>((iter){
                ret (continueF)(iter) and not iter.nextIs("\n\n");
              }));
      sectionMembers.add(Paragraph(^inlineNode));
    }
  }

  ret Section(^sectionMembers);
}







fn addLink(
    iter &InputIter)
Link {
  iter.skipExpect("[");
  linkText = iter.getUntilExpected("]");
  iter.skipExpect("(");
  linkUrl = iter.getUntilExpected(")");
  ret Link(linkText, linkUrl);
}


fn addInlineFullNote(
    notesCollector &NotesCollector,
    noteContents Section)
int {
  id = (mut notesCollector.nextId = notesCollector.nextId + 1);
  notesCollector.ids.add(id);

  notesCollector.noteContentsById.add(id, ^noteContents);

  ret id;
}

fn addNamedNoteAnchor(
    notesCollector &NotesCollector,
    noteName StrSlice)
int {
  id = (mut notesCollector.nextId = notesCollector.nextId + 1);
  notesCollector.ids.add(id);

  vassert(
      not notesCollector.idByName.has(noteName),
      "Note " + noteName + " already exists!");

  notesCollector.idByName.add(noteName, id);
  notesCollector.nameById.add(id, noteName);

  ret id;
}

fn addInlineNote(
    notesCollector &NotesCollector,
    iter &InputIter)
NoteAnchor {
  iter.skipExpect("[#");

  // If theres just space after the hash, then we're defining the note's text inline.
  if (iter.skipIfNext(" ")) {
    subNotes = NotesCollector(0);
    subNoteContents =
        parseInlines(
            subNotes,
            iter,
            &IFunction1<mut, &InputIter, bool>((iter){
              if (not iter.hasNext()) {
                panic("Must end note!");
              }
              ret not iter.skipIfNext("]");
            }));

    paragraph = Paragraph(^subNoteContents);
    section = Section(List<SectionMember>());
    section.members.add(^paragraph);

    ret NoteAnchor(addInlineFullNote(notesCollector, ^section));
  } else {
    noteName =
        iter.parseTextUntil(
            &IFunction1<mut, &InputIter, bool>((it){
              if (not iter.hasNext()) {
                panic("Must end note!");
              }
              ret not iter.skipIfNext("]");
            }));
    ret NoteAnchor(addNamedNoteAnchor(notesCollector, noteName));
  }
}

fn addSeparateNote(
    self &NotesCollector,
    noteName StrSlice,
    note Section) {
  vassert(
      self.idByName.has(noteName),
      "Note " + noteName + " doesn't exist!");
  id = self.idByName.get(noteName).get();


  vassert(
      not self.noteContentsById.has(id),
      "Note " + noteName + " already has contents!");

  self.noteContentsById.add(id, ^note);
}

