
fn void() { }


fn ltrimnl(s str) StrSlice { ltrimnl(s.slice()) }
fn ltrimnl(s! StrSlice) StrSlice {
  while (true) {
    if (s == "") {
      ret s;
    }
    if (s.slice(0, 1) != "\n") {
      ret s;
    }
    mut s = s.slice(1, s.len());
  }
  panic("unreachable");
}
fn rtrimnl(s str) StrSlice { rtrimnl(s.slice()) }
fn rtrimnl(s! StrSlice) StrSlice {
  whitespace = " \r\n\t";
  while (true) {
    if (s == "") {
      ret s;
    }
    if (s.slice(s.len() - 1, s.len()) != "\n") {
      ret s;
    }
    mut s = s.slice(0, s.len() - 1);
  }
  panic("unreachable");
}

fn trimnl(s str) StrSlice { trimnl(s.slice()) }
fn trimnl(s! StrSlice) StrSlice { ltrimnl(rtrimnl(s)) }




fn split(haystack str, needle str) List<StrSlice> {
  split(haystack.slice(), needle.slice())
}
fn split(haystack str, needle StrSlice) List<StrSlice> {
  split(haystack.slice(), needle)
}
fn split(haystack StrSlice, needle str) List<StrSlice> {
  split(haystack, needle.slice())
}
fn split(haystack! StrSlice, needle StrSlice) List<StrSlice> {
  result = List<StrSlice>();

  while (true) {
    maybeFirstAndRest = haystack.splitOnce(needle);
    if (maybeFirstAndRest.isEmpty()) {
      result.add(haystack);
      ret result;
    }
    (first, rest) = maybeFirstAndRest.get();
    result.add(first);
    mut haystack = rest;
  }

  panic("unreachable");
}


// untested
fn replaceAll(haystack StrSlice, needle StrSlice, replacement StrSlice) {
  result! = "";

  while (true) {
    maybeFirstAndRest = haystack.splitOnce(needle);
    if (maybeFirstAndRest.isEmpty()) {
      mut result = result + haystack;
      ret result;
    }
    (first, rest) = maybeFirstAndRest.get();
    result.add(first);
    result.add(replacement);
    mut haystack = rest;
  }

  panic("unreachable");
}


fn isWhitespace(s str) bool { isWhitespace(s.slice()) }
fn isWhitespace(s! StrSlice) bool {
  while (len(s) > 0) {
    if (" \r\n\t".find(s).isEmpty()) {
      // then its not whitespace
      ret false;
    }
    mut s = s.slice(1);
  }
  ret true;
}


fn executeProgram(command str) str extern;

// struct TestStruct {
//   x int;
//   s str;
// }
// fn newTestStruct(x int, s str) TestStruct export {
//   TestStruct(x, s)
// }
// fn dropTestStruct(this TestStruct) void export { }
// fn TestStruct_get_x(testStruct &TestStruct) int export { testStruct.x }
// fn TestStruct_get_s(testStruct &TestStruct) str export { testStruct.s }
